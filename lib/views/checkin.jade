extends ./base.jade

append body
    - this.checkData();
    if this.props.data
        .container
            h2 Wareneingang
                .btn-toolbar.pull-right
                    button.btn.btn-default(onClick=this.cancel)
                        i.glyphicon.glyphicon-chevron-left
                        |  Abbrechen
                    button.btn.btn-primary(onClick=this.save)
                        i.glyphicon.glyphicon-ok
                        |  Speichern
            .row
                .col-xs-12.col-md-8
                    h3 Equipment
                    table.table.table-striped.table-hover
                        thead
                            tr
                                th ID
                                th Name
                                th Anzahl
                                th Ausstehend
                        tbody
                            each type in this.props.data.types
                                if type.available !== undefined || type.count !== undefined
                                    tr
                                        td= type._id
                                        td= type.name
                                        td
                                            = (type.count||0)+" "
                                            if this.hasFromSuppliers(type)
                                                | (
                                                each supplier,id in type.suppliers
                                                    if supplier.count && id != "own"
                                                        img(src="/api/suppliers/"+id+"/image" height="25px")
                                                        = " "+supplier.count
                                                | )
                                        
                                        td
                                            = type.available+" "
                                            if Object.keys(type.suppliers).length > 1
                                                | (
                                                each supplier,id in type.suppliers
                                                    if id != "own"
                                                        img(src="/api/suppliers/"+id+"/image" height="25px" style="cursor:pointer" onClick=this.addFromSupplier(type,id))
                                                        = " "+supplier.available
                                                | )
                .col-md-4
                    .pull-left
                        h3 Verlauf
                    .btn-toolbar.pull-right(style="margin-top:18px")
                        ScanButton.pull-left(onScan=this.handleScan supplier="own")
                        .btn-group.pull-left(style="margin-left:10px")
                            div(className="btn "+(this.props.remove?"btn-primary":"btn-default") onClick=this.toggleMode) -
                            div(className="btn "+(this.props.remove?"btn-default":"btn-primary") onClick=this.toggleMode) +
                    table.table.table-striped.table-hover
                        thead
                            th
                            th
                            th Name
                        tbody
                            - console.log("COMPLETE LOG",this.props.log)
                            each log in this.props.log
                                - console.log("LOG ITEM",log)
                                +renderLogEntry(log,0)
    if this.props.stack
        .modal(style="display:block").fade.in
            .modal-backdrop(style="bottom:0px;display:block").fade.in
            .modal-dialog
                .modal-content
                    .modal-header
                        h2 Inhalt kontrollieren
                    .modal-body(style="maxHeight:500px;overflowY:auto")
                        table.table.table-striped
                            thead
                                tr
                                    th Name
                                    th Vorher
                                    th Nachher
                            tbody
                                each item,type in this.props.stack.contents
                                    tr
                                        td= this.props.data.types[type].name
                                        td= item.count
                                        td
                                            = item.newcount!==undefined?item.newcount:(item.ids?0:item.count)
                                            if !item.ids
                                                .btn-toolbar
                                                    button.btn.btn-danger.btn-xs(onClick=this.decreaseStack(type))
                                                        i.glyphicon.glyphicon-minus
                                                    button.btn.btn-success.btn-xs(onClick=this.increaseStack(type))
                                                        i.glyphicon.glyphicon-plus
                    .modal-footer
                        button.btn.btn-default(onClick=this.cancelStack) Abbrechen
                        button.btn.btn-primary(onClick=this.closeStack) Fertig
mixin renderLogEntry(log,level)
    - console.log("renderLogEntry",log,level);
    tr
        td(style=("color:"+(log.remove?"red":"green")))= level== 0?(log.remove?"-":"+"):""
        td
            if log.supplier && !level
                img(src="/api/suppliers/"+log.supplier+"/image" height="25px")
        td(style="paddingLeft:"+(level*20+8)+"px")
            if !log.item
                b= log.count+" "
            = this.props.data.types[log.type].name
            if log.item
                b= " #"+log.item
    each sub,type in log.contents
        if sub.newids
            each sublog in sub.newids
                +renderLogEntry(sublog,level+1)
        else
            tr 
                td
                td
                td(style="paddingLeft:"+((level+1)*20+8)+"px")
                    b= sub.newcount+" "
                    = this.props.data.types[type].name
script.
    var client = require("../client.js");
    var ScanButton = require("./ScanButton.jade");
    var async = require("async");
    
    exports.getNeededPermissions = function(){
        return ["projects_read"];
    }
    
    exports.checkData = function(){
        var self = this;
        if(this.props.data === undefined){
            client.getCheckin(this.props.params.project,this.props.params.checkin,function(err,data){
                if(err) return;
                self.props.data = data;
                self.props.log = [];
                self.update();
            });
        }
    }

    exports.cancel = function(){
        history.back();
    }
    exports.toggleMode = function(){
        if(this.props.remove){
            delete this.props.remove;
        }else{
            this.props.remove = true;
        }
        this.update();
    }
    
    exports.handleScan = function(code){
        if(code.kind != "EQ") return true;
        
        var type = this.props.data.types[code.type];
        if(!code.count) code.count = 1;
        
        if(this.props.remove){
            var missing = type.suppliers.own.count||0;
            console.log("missing",missing,type);
            if(code.count > missing){
                this.playErrorSound();
                code.count = missing;
            }
            if(!code.count) return;
            
            if(code.item){
                if((type.suppliers.own.ids||[]).indexOf(code.item) < 0){
                    this.playErrorSound();
                    return;
                }else{
                    type.suppliers.own.ids.splice(type.suppliers.own.ids.indexOf(code.item),1)
                }
            }
                       
            type.count = (type.count||0)-code.count;
            type.suppliers.own.count = (type.suppliers.own.count||0) - code.count;
            
            code.count = -code.count;
            code.remove = true;
            this.log(code);
        }else{
            if(this.props.stack) return this.handleStackScan(code);
            if(!type.available) return this.playErrorSound();
            var missing = type.suppliers.own.available-(type.suppliers.own.count||0);

            if((code.count) > missing){
            this.playErrorSound();
                code.count = missing;
            }
            if(!code.count) return;
            
            if(code.item){
                if((type.suppliers.own.ids||[]).indexOf(code.item) >= 0){
                    this.playErrorSound();
                    return;
                }else{
                    this.startStack(code);
                    return;
                }
            }            
            type.count = (type.count||0)+code.count;
            type.suppliers.own.count = (type.suppliers.own.count||0) + code.count;
            
            code.count = -code.count;
            this.log(code);
        }
        this.update();
    }
    
    exports.startStack = function(code){
        var self = this;
        async.parallel([
            function(cb){
                client.getEquipment(code.type,code.item,cb);
            },
            function(cb){
                client.getEquipmentType(code.type,cb);
            }
        ],function(err,results){
            var data = results[0];
            var type = results[1];
            type.contents = type.contents.map(function(type){return type._id});
        
            var parent = self.props.stack;
            var newStack = {type:code.type,item:code.item,contents:{},parent:parent};
            
            if(type.contents.length){
                this.props.stack = newStack;
            }
            
            for(var i = 0; i < type.contents.length; i++) {
                if(!this.props.data.types[type.contents[i]].suppliers) continue;
                newStack.contents[type.contents[i]] = {count:0,newcount:0};
                if(this.props.data.types[type.contents[i]].hasItems){
                    newStack.contents[type.contents[i]].ids = [];
                    newStack.contents[type.contents[i]].newids = {};
                }
            }
            
            for(var type in data.item.contents){
                newStack.contents[type].count = data.item.contents[type].count||0;
                if(this.props.data.types[type].hasItems){
                    newStack.contents[type].newcount = 0;
                    newStack.contents[type].ids = data.item.contents[type].ids||[];
                    newStack.contents[type].newids = {};
                }else{
                    newStack.contents[type].newcount = data.item.contents[type].count||0;
                }
            }
            
            if(parent){
                parent.contents[code.type].newids[code.item] = newStack;
                parent.contents[code.type].newcount++;
            }
                   

            this.update();
        }.bind(this));        
    }
    
    exports.handleStackScan = function(code){
        if(code.item){
            var stack = this.props.stack;
            if(!stack){
                this.startStack(code);
            }else{
                if(!stack.contents[code.type]){
                    this.closeStack(function(){
                        this.handleScan(code);
                    }.bind(this));
                    return;
                }
                if(stack.contents[code.type].newids && stack.contents[code.type].newids[code.item]){
                    this.playErrorSound();
                }else{
                    this.startStack(code);
                }
            }            
        }
    }
    
    exports.closeStack = function(cb){
        var stack = this.props.stack;
        var contents = {};
        for(var type in stack.contents){
            contents[type] = {count:stack.contents[type].newcount};
            var ids = Object.keys(stack.contents[type].newids||{}).map(function(id){return parseFloat(id)});
            if(ids.length){
                contents[type].ids = ids;
            }
        }        
        client.saveEquipment(stack.type,stack.item,{contents:contents},function(err){
            if(err) return;
            this.props.stack = stack.parent;
            if(!stack.parent){
                this.addItem(stack);
            }else{
                this.update();
            }           
            if(typeof cb == "function") cb();
        }.bind(this))
    }
    
    exports.cancelStack = function(){
        var stack = this.props.stack;
        var parent = stack.parent;
        if(parent){
            delete parent.contents[stack.type].newids[stack.item];
            parent.contents[stack.type].newcount--;
            this.props.stack = parent;
        }else{
            delete this.props.stack;
        }
        this.update();        
    }
    
    exports.increaseStack = function(type){
        console.log("TYPE",type);
        return function(){
            console.log("STACK",this.props.stack)
            console.log("NEWCOUNT",this.props.stack.contents[type].newcount);
            this.props.stack.contents[type].newcount += 1;
            this.update();
        }.bind(this)
    }
    
    exports.decreaseStack = function(type){
        return function(){
            this.props.stack.contents[type].newcount -= 1;
            this.update();
        }.bind(this)
    }
    
    exports.calcStackTotal = function(total,item){
        for(var type in item.contents){
            if(!total[type]) total[type] = {count:0};
            total[type].count += item.contents[type].newcount;
            for(var id in item.contents[type].newids){
                if(!total[type].ids) total[type].ids = [];
                total[type].ids.push(parseFloat(id));
                this.calcStackTotal(total,item.contents[type].newids[id]);
            }
        }
    }
    
    exports.addItem = function(stack){
        var total = {};
        total[stack.type] = {count:1,ids:stack.item};
        if(stack.contents){
            this.calcStackTotal(total,stack);
        }
        
        console.log("TOTAL",total);
        
        var error = false;
        loop: for(var type in total){
            var t = this.props.data.types[type];
            var own = t.suppliers.own;
            if(!own || total[type].count > own.available - own.count){
                error = true;
                break;
            }
            if(total[type].ids){
                for(var i = 0; i < total[type].ids.length; i++){
                    if(own.ids && own.ids.indexOf(total[type].ids[i]) >= 0){
                        error = true;
                        break loop;
                    }
                }
            }
        }
        
        if(error){
            this.playErrorSound();
        }else{
            this.log(stack);
            for(var type in total){
                if(this.props.data.types[type].count === undefined) this.props.data.types[type].count = 0;
                this.props.data.types[type].count = this.props.data.types[type].count||0 + total[type].count;
                this.props.data.types[type].suppliers.own.count = this.props.data.types[type].suppliers.own.count||0 + total[type].count;
                if(total[type].ids){
                    if(!this.props.data.types[type].suppliers.own.ids) this.props.data.types[type].suppliers.own.ids = [];
                    for(var i = 0; i < total[type].ids.length; i++){
                        this.props.data.types[type].suppliers.own.ids.push(total[type].ids[i])
                    }
                }
            }
        }
        
        this.update();
    }
    
    
    exports.hasFromSuppliers = function(type){
        for(var supplier in type.suppliers) if(supplier != "own" && type.suppliers[supplier].count > 0) return true;
        return false;
    }
    
    exports.addFromSupplier = function(type,supplier){
        return function(){
            if(this.props.remove){
                if(type.suppliers[supplier].count > 0){
                    type.suppliers[supplier].count --;
                    if(!type.suppliers[supplier]) delete type.suppliers[supplier].count;
                    type.count --;
                    this.log({type:type._id,count:1,supplier:supplier,remove:true})
                }
            }else{
                if((type.suppliers[supplier].count||0) < type.suppliers[supplier].available){
                    type.suppliers[supplier].count = (type.suppliers[supplier].count ||0)+1;
                    type.count ++;
                    this.log({type:type._id,count:1,supplier:supplier})
                }                
            }

            this.update();
        }.bind(this)
    }
    
    exports.log = function(stack){
        this.props.log.push(stack);
        while(this.props.log.length > 10) this.props.log.shift();
    }
    
    exports.playErrorSound = function(){
        new Audio("/public/audio/error.wav").play();
    }

    exports.save = function(){
        var data = {};
        for(var type in this.props.data.types){
            var t = this.props.data.types[type];
            if(!t.count) continue;
            data[type] = {
                count:t.count,
                suppliers:{}
            };
            for(var supplier in t.suppliers){
                if(!t.suppliers[supplier].count) continue;
                data[type].suppliers[supplier] = {
                    count:t.suppliers[supplier].count,
                    ids:t.suppliers[supplier].ids
                };
            }
        }
    
        client.updateCheckin(this.props.params.project,this.props.params.checkin,data,function(err){
            if(err) return true;
            back(true);
        });
    }
